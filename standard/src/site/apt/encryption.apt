 ---
 Encryption

Introduction

 B1 archive encryption is used to provide confidentiality, integrity and authenticity of an archive.
The B1 archive format supports password-based AES-256 encryption in GCM mode.

Restrictions

 An archive is encrypted if each volume has a head item "e:1/<iteration count>", where
the iteration count is choosen to be quite large to increase the difficulty of a brute-force attack.

 The encryption adds the following restrictions to the archive structure:

 * The head item "a:" (archive identifier) must contain a base64-encoded 256-bit value,
   generated with a cryptographically secure pseudo-random number generator.

 * A head and/or a tail can have a single item "x:<base64>", that contains other items encrypted;

 * The head items "t:" and ":m", if present, must be moved to the "x:" head item, i.e. encrypted;

 * The tail item "c:", if present, must be moved to the "x:" tail item, i.e. encrypted;

 * Only blocks of type "AesBlock" are allowed.

Implementation

 The following steps should be performed for encryption:

 * A 256-bit archive salt is obtained by base64-decoding the archive identifier;

 * An iteration count is taken from the head item "e:1/<iteration count>";

 * An archive key is generated using PBKDF2 from PKCS #5 with HMAC-SHA256 as follows:

---
   archiveKey = PBKDF2(HMAC-SHA256, userPassword, archiveSalt, iterationCount, 256);
---

 * A volume salt is obtained by UTF-8 encoding a decimal representation of the volume number from the head item "n:";

---
   volumeSalt = UTF8(volumeNumber);
---

 * A volume key is generated by HMAC-SHA256 from the archive key and the volume salt as follows:

---
   volumeKey = HMAC-SHA256(archiveKey, volumeSalt);
---

 * The head and tail salts are single bytes, 0x01 and 0x02 respectively;

 * The block salt is a UTF-8 encoded decimal representation of the block offset from the beginning of a volume;

---
   blockSalt = UTF8(blockOffset);
---

 * Head, tail, and block keys are obtained as followes:

---
   headKey = HMAC-SHA256(volumeKey, headSalt),
   tailKey = HMAC-SHA256(volumeKey, tailSalt),
   blockKey = HMAC-SHA256(volumeKey, blockSalt);
---

 * The head of the first volume must have an "x:" item built as follows. A text string containing space separated items
   "t:" and/or "m:" is formed. If there are no such items the string is empty. After that the string is UTF-8 encoded,
   encrypted with the head key, base64 encoded, appended to "x:" and stored as a head item:

---
    "x:" + BASE64(AES-256-GCM(headKey, UTF8("t:<number>")));
---

 * If a tail contains a "c:" item, it should be UTF-8 encoded, encrypted with the tail key, base64 encoded,
   appended to "x:" and stored as a tail item:

---
    "x:" + BASE64(AES-256-GCM(tailKey, UTF8("c:<volume number>/<block offset>/<record offset>")));
---

 * Each "Block" is replaced with another "Block" containing "AesBlock" with the encrypted binary represendation
   of the original block:

---
    encryptedBlock = AES-256-GCM(blockKey, block);
---

 * When performing AES-256 encryption in GCM mode the initialization vector consists of 96 zero bits,
   the additional authenticated data parameter is empty, and the generated 128-bit tag (MAC) is appended
   to the end of the encrypted message.
